<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv=content-security-policy content="default-src 'none'; script-src 'self' 'unsafe-eval' 'unsafe-inline' https:; style-src 'self' 'unsafe-inline' https:; font-src 'self' https://fonts.gstatic.com; frame-src 'self' https:; img-src 'self' data: https:; connect-src 'self' https:; worker-src blob:;">
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://metrics.couchbase.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-MVPNN2');</script>
<!-- End Google Tag Manager -->
<title>Distributed Transactions from the Java SDK | Couchbase Docs</title>
<link rel="canonical" href="https://docs.couchbase.com/java-sdk/current/howtos/distributed-acid-transactions-from-the-sdk.html">
<link rel="stylesheet" href="../../../_/css/site.css">
<script src="../../../_/js/vendor/jquery.js"></script>
<link rel="schema.dcterms" href="https://purl.org/dc/terms/">


<meta name="dcterms.subject" content="java-sdk">
<meta name="dcterms.identifier" content="3.0">
<meta name="page-url" content="/java-sdk/3.0/howtos/distributed-acid-transactions-from-the-sdk.html">
<meta name="page-nav-header-levels" content="0">
<meta name="generator" content="Antora 3.1.7">
<link rel="icon" href="../../../_/img/favicon.svg" type="image/svg+xml">
<link rel="icon" href="../../../_/img/favicon.ico" type="image/x-icon" sizes="any">
</head>
<body class="article">
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-MVPNN2" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<header class="header fixed-top">
  <div class="header-top-row">
      <div class="container">
          <nav class="navbar navbar-expand-md flex-nowrap justify-content-between navbar-new-top">
              <ul class="navbar-brand-list">
                <li class="brand-logo">
                  <a class="navbar-brand" href="https://www.couchbase.com">
                    <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase" />
                  </a>
                </li>
                <li>
                  <a class="navbar-brand cb-documentation" href="https://docs.couchbase.com/home/index.html">
                    <img src="../../../_/img/cb-documentation.svg" alt="Couchbase Documentation" class="cb-docs" />
                    <img src="../../../_/img/cb-docs-hover.svg" alt="Couchbase Documentation" class="hide cb-hover-docs" />
                  </a>
                </li>
              </ul>
              <button class="navbar-burger" data-target="topbar-menu">
                <span></span>
                <span></span>
                <span></span>
              </button>

          </nav>
      </div>
  </div>
  <div class="header-bottom-row" id="topbar-menu">
    <div class="container">
        <nav  class="navbar navbar-new-bottom">

              <div class="navbar-collapse collapse" id="navbar2">
                <ul class="navbar-nav w-100 justify-content-start">
                  <li class="nav-item">
                    <a href="https://docs.couchbase.com/home/index.html" class="nav-link">
                      <i class="fas fa-home"></i>
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/server.html">
                      Server
                    </a>
                  </li>
                  <li class="nav-item">
                    <a class="nav-link" href="../../../home/mobile.html">
                      Mobile
                    </a>
                  </li>
                </ul>
              </div>
              <div class="primary-action">
                <a class="btn btn-primary btn-grey-reverse" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Download'});" href="https://www.couchbase.com/downloads">
                  Downloads
                  <i class="far fa-arrow-to-bottom fa-fw"></i>
                </a>
                <a href="https://cloud.couchbase.com/sign-up" class="btn btn-primary" onclick="(window.dataLayer=window.dataLayer||[]).push({'event':'customEvent', 'category':'CTA', 'action':'Button Click',  'label':'Free Trial'});" >
                  Start Free Trial
                  <i class="far fa-cloud fa-fw"></i>
                </a>

              </div>

        </nav>
    </div>
   </div>
</header>
<div class="body container">
<aside class="nav left-sidebar">
  <div class="nav-container">
    <a href="#" class="menu-expand-toggle"><span>Navigation</span><i class="fas fa-times-circle"></i><i class="fas fa-chevron-circle-left"></i></a>
    <template id="page-versions" style="display: none">
      <select class="version_list" data-component="java-sdk">
        <option value="3.4" data-url="../../current/howtos/distributed-acid-transactions-from-the-sdk.html">3.4</option>
        <option value="3.3" data-url="../../3.3/howtos/distributed-acid-transactions-from-the-sdk.html">3.3</option>
        <option value="3.2" data-url="../../3.2/howtos/distributed-acid-transactions-from-the-sdk.html">3.2</option>
        <option value="3.1" data-url="../../3.1/howtos/distributed-acid-transactions-from-the-sdk.html">3.1</option>
        <option value="3.0" data-url="distributed-acid-transactions-from-the-sdk.html" selected>3.0</option>
      </select>
    </template>
  </div>
</aside>
<aside class="toc sidebar"
      data-title="Contents"
      data-levels="1">
  <div class="sidebar-box">
    <div class="tools" role="navigation">
<ul>
<li class="tool edit"><a href="https://github.com/couchbase/docs-sdk-java/edit/release/3.0/modules/howtos/pages/distributed-acid-transactions-from-the-sdk.adoc" title="Edit Page" target="_blank" rel="noopener" class="remove-ext-icon">Edit on GitHub</a></li>
</ul>
</div>
    <div class="toc-menu"></div>
    <div class="is-this-helpful-box">
      <h4> Is this page helpful?</h4>
      <div class="btn-row">
        <a href="#" class="like-btn helpful-btn" id="yesBtn" data-page-rating="like" >
                <i class="far fa-thumbs-up"></i>
            Yes

            </a>
        <a href="#" class="dislike-btn helpful-btn" id="noBtn"  data-page-rating="dislike"> <i class="far fa-thumbs-down"></i> No</a>
      </div>
      <div class="any-feedback">
        <a href="#" class="btn any-feedback-btn" id="myCustomTrigger">Leave Additional Feedback? </a>
      </div>
      <div class="dialog-box" id="dialogBox">
        <form>
            <div class="form-group " id="additionalFeedbackBox">
              <textarea class="input-control feed-back-msg" rows="8" placeholder="Any Additonal Feedback?"></textarea>

              <div class="action-btn-row ">
                <a href="#" class="skip-btn" id="skipBtnMsg">Skip</a>
                  <button class="submit-btn btn blue-btn disabled" > Submit  </button>
                  <a href="#" class="info-btn"><i class="fas fa-info-circle"></i></a>
              </div>


            </div>

        </form>

      </div>
    </div>
  </div>

</aside>

<div class="feedback-modal modal-popup">
  <div class="modal-popup-dialogue">
    <div class="popup-header">
      <a href="#" class="close-popup"><i class="fa fa-times"></i></a>
    </div>
    <div class="popup-content">
      <p>
        Please use the form below to provide your feedback. Because your feedback is valuable to us,
         the information you submit in this form is recorded in our issue tracking system (JIRA), which is publicly available.
        You can track the status of your feedback using the ticket number displayed in the dialog once you submit the form.
      </p>
    </div>
  </div>
</div>

<main class="article" data-ceiling="topbar">
<div class="article-banner">
<i class="fas fa-file-alt"></i> <p>A newer version of this documentation is available.</p>
<a class="btn" href="../../current/howtos/distributed-acid-transactions-from-the-sdk.html">View Latest</a>
</div>
<div class="article-header">
<nav class="crumbs" aria-label="breadcrumbs">
<ul>
<li class="crumb"><a href="../hello-world/start-using-sdk.html">Java SDK</a></li>
<li class="crumb">Advanced Data Operations</li>
<li class="crumb"><a href="distributed-acid-transactions-from-the-sdk.html">Distributed ACID Transactions</a></li>
</ul>
</nav>
</div>
<article class="doc">
<div class="page-heading-title">
<h1 class="page">Distributed Transactions from the Java SDK</h1>
<div class="labels">
<ul><li class="guide"><span><i class="far fa-check-square"></i> how-to</span></li>
</ul>
</div>


</div>
<div class="contributor-list-box">
<span class="last-commit-date" id="commitdate">    </span>
<ul id="contributorList"></ul>
<span  id="otherContributor"> + </span>
</div><div id="preamble">
<div class="sectionbody">
<div class="quoteblock abstract">
<blockquote>
A practical guide to using Couchbaseâ€™s distributed ACID transactions, via the Java API.
</blockquote>
</div>
<div class="paragraph">
<p>Distributed Transactions for Couchbase provide these semantics and features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Insertion, mutation, and removal of multiple documents can be staged inside a transaction.</p>
</li>
<li>
<p>Until the transaction is committed, these changes will not be visible to other transactions, or any other part of the Couchbase Data Platform.</p>
</li>
<li>
<p>An isolation level of Read Committed, to support high performance and scalability.</p>
</li>
<li>
<p>A high-level and easy-to-use API that allows the developer to express what they want the transaction to do as a block of logic, while the library takes care of the details of error handling, including conflicts with other transactions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Please see <a href="#6.6@server:learn:data/transactions.adoc" class="xref unresolved">our introduction to ACID Transactions</a> for a guide to the benefits and trade-offs of multi-document transactions.</p>
</div>
<div class="paragraph">
<p>Below we show you how to create Transactions, step-by-step.
You may also want to start with our <a href="https://github.com/couchbaselabs/couchbase-transactions-java-examples">transactions examples repository</a>,
which features useful downloadable examples of using Distributed Transactions.</p>
</div>
<div class="paragraph">
<p>Javadocs are available <a href="https://docs.couchbase.com/sdk-api/couchbase-transactions-java-1.1.0/index.html?overview-summary.html">online</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="requirements"><a class="anchor" href="#requirements"></a>Requirements</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Couchbase Server 6.6 or above.</p>
</li>
<li>
<p>Couchbase Java client 3.0.7 or above.  It is recommended to follow the transitive dependency for the transactions library from maven.</p>
</li>
<li>
<p>NTP should be configured so nodes of the Couchbase cluster are in sync with time.</p>
</li>
<li>
<p>The application, if it is using <a href="../concept-docs/xattr.html" class="xref page">extended attributes (XATTRs)</a>, must avoid using the XATTR field <code>txn</code>, which is reserved for Couchbase use.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If using a single node cluster (for example, during development), then note that the default number of replicas for a newly created bucket is 1.
If left at this default, then all Key-Value writes performed at with durabiltiy will fail with a <code>DurabilityImpossibleException</code>.
In turn this will cause all transactions (which perform all Key-Value writes durably) to fail.
This setting can be changed via <a href="#6.6@server:manage:manage-buckets/create-bucket.adoc#couchbase-bucket-settings" class="xref unresolved">GUI</a> or <a href="../../../server/6.6/cli/cbcli/couchbase-cli-bucket-create.html#options" class="xref page">command line</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>Getting Started</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Couchbase transactions require no additional components or services to be configured.
Simply add the transactions library into your project.
The latest version, as of November 2020, is 1.1.3.</p>
</div>
<div class="paragraph">
<p>With Gradle this can be accomplished by modifying these sections of your build.gradle file like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">dependencies {
    compile group: 'com.couchbase.client', name: 'couchbase-transactions', version: '1.1.3'
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use the same group, artifact, and version in your Maven-compatible tool of choice.</p>
</div>
<div class="paragraph">
<p>A complete simple gradle project is available on our <a href="https://github.com/couchbaselabs/couchbase-transactions-java-examples">transactions examples repository</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="initializing-transactions"><a class="anchor" href="#initializing-transactions"></a>Initializing Transactions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Here are all imports used by the following examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L18-L51">import com.couchbase.client.core.cnc.Event;
import com.couchbase.client.java.Bucket;
import com.couchbase.client.java.Cluster;
import com.couchbase.client.java.Collection;
import com.couchbase.client.java.ReactiveCollection;
import com.couchbase.client.java.json.JsonObject;
import com.couchbase.client.java.kv.GetResult;
import com.couchbase.client.java.query.QueryOptions;
import com.couchbase.client.java.query.QueryProfile;
import com.couchbase.client.java.query.QueryResult;
import com.couchbase.transactions.TransactionDurabilityLevel;
import com.couchbase.transactions.TransactionGetResult;
import com.couchbase.transactions.TransactionQueryOptions;
import com.couchbase.transactions.TransactionResult;
import com.couchbase.transactions.Transactions;
import com.couchbase.transactions.config.TransactionConfigBuilder;
import com.couchbase.transactions.deferred.TransactionSerializedContext;
import com.couchbase.transactions.error.TransactionCommitAmbiguous;
import com.couchbase.transactions.error.TransactionFailed;
import com.couchbase.transactions.log.IllegalDocumentState;
import com.couchbase.transactions.log.LogDefer;
import com.couchbase.transactions.log.TransactionCleanupAttempt;
import com.couchbase.transactions.log.TransactionCleanupEndRunEvent;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Logger;

import static com.couchbase.client.java.query.QueryOptions.queryOptions;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The starting point is the <code>Transactions</code> object.
It is very important that the application ensures that only one of these is created, as it performs automated background processes that should not be duplicated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L61-L67">// Initialize the Couchbase cluster
Cluster cluster = Cluster.connect("localhost", "transactor", "mypass");
Bucket bucket = cluster.bucket("transact");
Collection collection = bucket.defaultCollection();

// Create the single Transactions object
Transactions transactions = Transactions.create(cluster);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration"><a class="anchor" href="#configuration"></a>Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Transactions can optionally be configured at the point of creating the <code>Transactions</code> object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L77-L83">Transactions transactions = Transactions.create(cluster,
        TransactionConfigBuilder.create()
                .durabilityLevel(TransactionDurabilityLevel.PERSIST_TO_MAJORITY)
                .logOnFailure(true, Event.Severity.WARN)
            .build());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default configuration will perform all writes with the durability setting <code>Majority</code>, ensuring that each write is available in-memory on the majority of replicas before the transaction continues.
There are two higher durability settings available that will additionally wait for all mutations to be written to physical storage on either the active or the majority of replicas, before continuing.
This further increases safety, at a cost of additional latency.</p>
</div>
<div class="paragraph">
<p>A level of <code>None</code> is present but its use is discouraged and unsupported.
If durability is set to <code>None</code>, then atomicity <em>cannot be guaranteed</em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-a-transaction"><a class="anchor" href="#creating-a-transaction"></a>Creating a Transaction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A core idea of the library is that the application supplies the logic for transaction inside a lambda, including any conditional logic required, and the transactions library takes care of getting the transaction committed.</p>
</div>
<div class="paragraph">
<p>It is important to understand that the lambda may be run multiple times in order to handle some types of transient error, such as a temporary conflict with another transaction.</p>
</div>
<div class="paragraph">
<p>Each run of the lambda is called an <code>attempt</code>, inside an overall <code>transaction</code>.</p>
</div>
<div class="paragraph">
<p>As with the Couchbase Java Client, you can use the library in either synchronous mode (the exceptions will be explained later in <a href="#error-handling">Error Handling</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L89-L117">try {
    transactions.run((ctx) -&gt; {
        // 'ctx' is an AttemptContext, which permits getting, inserting,
        // removing and replacing documents, along with committing and
        // rolling back the transaction.

        // ... Your transaction logic here ...

        // This call is optional - if you leave it off, the transaction
        // will be committed anyway.
        ctx.commit();
    });
} catch (TransactionCommitAmbiguous e) {
    // The application will of course want to use its own logging rather
    // than System.err
    System.err.println("Transaction possibly committed");

    for (LogDefer err : e.result().log().logs()) {
        System.err.println(err.toString());
    }
} catch (TransactionFailed e) {
    System.err.println("Transaction did not reach commit point");

    for (LogDefer err : e.result().log().logs()) {
        System.err.println(err.toString());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or asynchronous modes, using the Project Reactor reactive library:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L123-L154">Mono&lt;TransactionResult&gt; result = transactions.reactive().run((ctx) -&gt; {
    // 'ctx' is an AttemptContextReactive, providing asynchronous versions of the AttemptContext methods

    return

            // Your transaction logic here: as an example, get and remove a doc
            ctx.get(collection.reactive(), "document-id")
                    .flatMap(doc -&gt; ctx.remove(doc))

                    // The commit call is optional - if you leave it off,
                    // the transaction will be committed anyway.
                    .then(ctx.commit());
}).doOnError(err -&gt; {
    if (err instanceof TransactionCommitAmbiguous) {
        System.err.println("Transaction possibly committed: ");
    }
    else {
        System.err.println("Transaction failed: ");
    }

    for (LogDefer e : ((TransactionFailed) err).result().log().logs()) {
        // System.err is used for example, log failures to your own logging system
        System.err.println(err.toString());
    }
});


// Normally you will chain this result further and ultimately subscribe.  For simplicity, here we just block
// on the result.
TransactionResult finalResult = result.block();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The synchronous mode is the easiest to write and understand.
The asynchronous API allows you to build your application in a reactive style, without large thread pools, which can help you scale with excellent efficiency.
Those new to reactive programming may want to check out <a href="https://projectreactor.io/">the Project Reactor site</a> for more details on this powerful paradigm.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Some <code>AttemptContextReactive</code> methods, notably <code>remove</code>, return <code>Mono&lt;Void&gt;</code>.
Be careful to use <code>then</code> rather than <code>flatMap</code> or similar on these,
as <code>Mono&lt;Void&gt;</code> will only trigger a completion event, and not the next event,
so many methods including flatMap will not work as expected.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A code example is worth a thousand words, so here is a quick summary of the main transaction operations.
They are described in more detail below.</p>
</div>
<div class="listingblock">
<div class="title">With the synchronous API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L160-L198">try {
    TransactionResult result = transactions.run((ctx) -&gt; {
        // Inserting a doc:
        ctx.insert(collection, "doc-a", JsonObject.create());

        // Getting documents:
        // Use ctx.getOptional if the document may or may not exist
        Optional&lt;TransactionGetResult&gt; docOpt =
                ctx.getOptional(collection, "doc-a");

        // Use ctx.get if the document should exist, and the transaction
        // will fail if it does not
        TransactionGetResult docA = ctx.get(collection, "doc-a");

        // Replacing a doc:
        TransactionGetResult docB = ctx.get(collection, "doc-b");
        JsonObject content = docB.contentAs(JsonObject.class);
        content.put("transactions", "are awesome");
        ctx.replace(docB, content);

        // Removing a doc:
        TransactionGetResult docC = ctx.get(collection, "doc-c");
        ctx.remove(docC);

        ctx.commit();
    });
} catch (TransactionCommitAmbiguous e) {
    System.err.println("Transaction possibly committed");

    for (LogDefer err : e.result().log().logs()) {
        System.err.println(err.toString());
    }
} catch (TransactionFailed e) {
    System.err.println("Transaction did not reach commit point");

    for (LogDefer err : e.result().log().logs()) {
        System.err.println(err.toString());
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">With the asynchronous API</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L204-L240">Mono&lt;TransactionResult&gt; result = transactions.reactive().run((ctx) -&gt; {
    return
            // Inserting a doc:
            ctx.insert(collection.reactive(), "doc-a", JsonObject.create())

                    // Getting and replacing a doc:
                    .then(ctx.get(collection.reactive(), "doc-b"))
                    .flatMap(docB -&gt; {
                        JsonObject content = docB.contentAs(JsonObject.class);
                        content.put("transactions", "are awesome");
                        return ctx.replace(docB, content);
                    })

                    // Getting and removing a doc:
                    .then(ctx.get(collection.reactive(), "doc-c"))
                    .flatMap(doc -&gt; ctx.remove(doc))

                    // Committing:
                    .then(ctx.commit());

}).doOnError(err -&gt; {
    if (err instanceof TransactionCommitAmbiguous) {
        System.err.println("Transaction possibly committed: ");
    }
    else {
        System.err.println("Transaction failed: ");
    }

    for (LogDefer e : ((TransactionFailed) err).result().log().logs()) {
        // System.err is used for example, log failures to your own logging system
        System.err.println(err.toString());
    }
});

// Normally you will chain this result further and ultimately subscribe.
// For simplicity, here we just block on the result.
result.block();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mechanics"><a class="anchor" href="#mechanics"></a>Transaction Mechanics</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While this document is focussed on presenting how transactions are used at the API level, it is useful to have a high-level understanding of the mechanics.
Reading this section is completely optional.</p>
</div>
<div class="paragraph">
<p>Recall that the application-provided lambda (containing the transaction logic) may be run multiple times by the transactions library.
Each such run is called an 'attempt' inside the overall transaction.</p>
</div>
<div class="sect2">
<h3 id="active-transaction-record-entries"><a class="anchor" href="#active-transaction-record-entries"></a>Active Transaction Record Entries</h3>
<div class="paragraph">
<p>The first mechanic is that each of these attempts adds an entry to a metadata document in the Couchbase cluster.
These metadata documents:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Are named Active Transaction Records, or ATRs.</p>
</li>
<li>
<p>Are created and maintained automatically.</p>
</li>
<li>
<p>Begin with "_txn:atr-".</p>
</li>
<li>
<p>Each contain entries for multiple attempts.</p>
</li>
<li>
<p>Are viewable, and <em>they should not be modified externally</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Each such ATR entry stores some metadata and, crucially, whether the attempt has committed or not.
In this way, the entry acts as the single point of truth for the transaction, which is essential for providing an 'atomic commit' during reads.</p>
</div>
</div>
<div class="sect2">
<h3 id="staged-mutations"><a class="anchor" href="#staged-mutations"></a>Staged Mutations</h3>
<div class="paragraph">
<p>The second mechanic is that mutating a document inside a transaction, does not directly change the body of the document.
Instead, the post-transaction version of the document is staged alongside the document (technically in its <a href="../concept-docs/xattr.html" class="xref page">extended attributes (XATTRs)</a>).
In this way, all changes are invisible to all parts of the Couchbase Data Platform until the commit point is reached.</p>
</div>
<div class="paragraph">
<p>These staged document changes effectively act as a lock against other transactions trying to modify the document, preventing write-write conflicts.</p>
</div>
</div>
<div class="sect2">
<h3 id="cleanup"><a class="anchor" href="#cleanup"></a>Cleanup</h3>
<div class="paragraph">
<p>There are safety mechanisms to ensure that leftover staged changes from a failed transaction cannot block live transactions indefinitely.
These include an asynchronous cleanup process that is started with the creation of the <code>Transactions</code> object, and scans for expired transactions created by any application, on all buckets.</p>
</div>
<div class="paragraph">
<p>Note that if an application is not running, then this cleanup is also not running.</p>
</div>
<div class="paragraph">
<p>The cleanup process is detailed below in <a href="#asynchronous-cleanup">Asynchronous Cleanup</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="committing"><a class="anchor" href="#committing"></a>Committing</h3>
<div class="paragraph">
<p>Only once the lambda has successfully run to conclusion, will the attempt be committed.
This updates the attempt entry, which can be used as a signal by transactional actors as to whether to use the post-transaction version of a document from its XATTRs.
Hence updating the ATR entry is effectively an 'atomic commit' switch for the transaction.</p>
</div>
<div class="paragraph">
<p>After this atomic commit point is reached, the individual documents be committed (or "unstaged").
This provides an eventually consistent commit for non-transactional actors (including standard Key-Value reads and N1QL statements).
Transactions will begin reading the post-transactional version of documents as soon as the ATR entry is changed to committed.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mutating-documents"><a class="anchor" href="#mutating-documents"></a>Mutating Documents</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="replacing"><a class="anchor" href="#replacing"></a>Replacing</h3>
<div class="paragraph">
<p>Replacing a document requires a <code>ctx.get()</code> call first.
This is necessary to ensure that the document is not involved in another transaction.
(If it is, then the transaction will handle this, generally by rolling back what has been done so far, and retrying the lambda.)</p>
</div>
<div class="listingblock">
<div class="title">With the synchronous API:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L291-L296">transactions.run((ctx) -&gt; {
    TransactionGetResult anotherDoc = ctx.get(collection, "anotherDoc");
    JsonObject content = anotherDoc.contentAs(JsonObject.class);
    content.put("transactions", "are awesome");
    ctx.replace(anotherDoc, content);
});</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Asynchronous API:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L302-L310">transactions.reactive().run((ctx) -&gt; {
    return ctx.get(collection.reactive(), "anotherDoc")
            .flatMap(doc -&gt; {
                JsonObject content = doc.contentAs(JsonObject.class);
                content.put("transactions", "are awesome");
                return ctx.replace(doc, content);
            })
            .then(ctx.commit());
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="removing"><a class="anchor" href="#removing"></a>Removing</h3>
<div class="paragraph">
<p>As with replaces, removing a document requires a <code>ctx.get()</code> call first.</p>
</div>
<div class="listingblock">
<div class="title">With the asynchronous API:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L325-L328">transactions.reactive().run((ctx) -&gt; {
    return ctx.get(collection.reactive(), "anotherDoc")
            .flatMap(doc -&gt; ctx.remove(doc));
});</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Synchronous API:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L316-L319">transactions.run((ctx) -&gt; {
    TransactionGetResult anotherDoc = ctx.get(collection, "anotherDoc");
    ctx.remove(anotherDoc);
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="inserting"><a class="anchor" href="#inserting"></a>Inserting</h3>
<div class="listingblock">
<div class="title">With the asynchronous API:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L247-L249">transactions.reactive().run((ctx) -&gt; {
    return ctx.insert(collection.reactive(), "docId", JsonObject.create()).then();
}).block();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">With the synchronous API:</div>
<div class="content">
<pre data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L255-L260">transactions.run((ctx) -&gt; {
    String docId = "docId";

    ctx.insert(collection, docId, JsonObject.create());

});</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-documents"><a class="anchor" href="#getting-documents"></a>Getting Documents</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are two ways to get a document, <code>get</code> and <code>getOptional</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L266-L271">transactions.run((ctx) -&gt; {
    String docId = "a-doc";

    Optional&lt;TransactionGetResult&gt; docOpt = ctx.getOptional(collection, docId);
    TransactionGetResult doc = ctx.get(collection, docId);
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>get</code> will cause the transaction to fail with <code>TransactionFailed</code> (after rolling back any changes, of course).
It is provided as a convenience method so the developer does not have to check the <code>Optional</code> if the document must exist for the transaction to succeed.</p>
</div>
<div class="paragraph">
<p>Gets will 'read your own writes', e.g. this will succeed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L277-L285">transactions.run((ctx) -&gt; {
    String docId = "docId";

    ctx.insert(collection, docId, JsonObject.create());

    Optional&lt;TransactionGetResult&gt; doc = ctx.getOptional(collection, docId);

    assert (doc.isPresent());
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="n1ql-queries"><a class="anchor" href="#n1ql-queries"></a>N1QL Queries</h2>
<div class="sectionbody">
<div class="paragraph">
<p>With Couchbase Server 7.0 beta and the 1.1.3 release of this library, comes support for using N1QL queries inside the transaction lambda.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Support for queries in 1.1.3 is at beta level and is marked as @Stability.Volatile, which means the API may need to change as we gather feedback during the Couchbase Server 7.0 beta period.
The feature should not be used in any production deployment while it is at beta level.
Please take this opportunity to provide feedback on this feature, via either support or our forums.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you have used N1QL queries from the regular Java SDK, then you already know how to use queries inside the lambda, as the syntax is almost identical:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L685-L693">transactions.run((ctx) -&gt; {
    ctx.query("INSERT INTO `default` VALUES ('doc', {'hello':'world'})");

    String st = "SELECT `default`.* FROM `default` WHERE META().id = 'doc'";
    QueryResult qr = ctx.query(st);
    qr.rowsAsObject().forEach(row -&gt; {
        System.out.println(row);
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that we are performing queries on the <code>ctx</code> object.
This is very important: queries performed on a <code>Cluster</code> or <code>Scope</code> object inside the lambda will just act like a normal query and will not be part of the transaction.</p>
</div>
<div class="paragraph">
<p>Key-Value operations and queries can be freely intermixed, and will 'see' each other as you would expect:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L699-L707">transactions.run((ctx) -&gt; {
    ctx.insert(collection, "doc", JsonObject.create().put("hello", "world"));

    String st = "SELECT `default`.* FROM `default` WHERE META().id = 'doc'";
    QueryResult qr = ctx.query(st);
    qr.rowsAsObject().forEach(row -&gt; {
        System.out.println(row);
    });
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>For performance reasons it&#8217;s recommended to put Key-Value operations before the first query in the lambda if possible, as after that point they incur a small translation cost.</p>
</div>
<div class="paragraph">
<p>Query options can be provided via <code>TransactionsQueryOptions</code>, which provides a subset of the options in the Java SDK&#8217;s <code>QueryOptions</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L713-L716">transactions.run((ctx) -&gt; {
    ctx.query("INSERT INTO `default` VALUES ('doc', {'hello':'world'})",
            TransactionQueryOptions.queryOptions().profile(QueryProfile.TIMINGS));
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="committing-2"><a class="anchor" href="#committing-2"></a>Committing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Committing is automatic: if there is no explicit call to <code>ctx.commit()</code> at the end of the transaction logic callback, and no exception is thrown, it will be committed.</p>
</div>
<div class="paragraph">
<p>With the asynchronous API, if you leave off the explicit call to <code>commit</code> then you may need to call <code>.then()</code> on the result of the chain to convert it to the required <code>Mono&lt;Void&gt;</code> return type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L334-L342">Mono&lt;TransactionResult&gt; result = transactions.reactive().run((ctx) -&gt; {
    return ctx.get(collection.reactive(), "anotherDoc")
            .flatMap(doc -&gt; {
                JsonObject content = doc.contentAs(JsonObject.class);
                content.put("transactions", "are awesome");
                return ctx.replace(doc, content);
            })
            .then();
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>As described above, as soon as the transaction is committed, all its changes will be atomically visible to reads from other transactions.
The changes will also be committed (or "unstaged") so they are visible to non-transactional actors, in an eventually consistent fashion.</p>
</div>
<div class="paragraph">
<p>Commit is final: after the transaction is committed, it cannot be rolled back, and no further operations are allowed on it.</p>
</div>
<div class="paragraph">
<p>An asynchronous cleanup process ensures that once the transaction reaches the commit point, it will be fully committed - even if the application crashes.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="a-full-transaction-example"><a class="anchor" href="#a-full-transaction-example"></a>A Full Transaction Example</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s pull together everything so far into a more real-world example of a transaction.</p>
</div>
<div class="paragraph">
<p>This example simulates a simple Massively Multiplayer Online game, and includes documents representing:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Players, with experience points and levels;</p>
</li>
<li>
<p>Monsters, with hitpoints, and the number of experience points a player earns from their death.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In this example, the player is dealing damage to the monster.
The playerâ€™s client has sent this instruction to a central server, where weâ€™re going to record that action.
Weâ€™re going to do this in a transaction, as we donâ€™t want a situation where the monster is killed, but we fail to update the playerâ€™s document with the earned experience.</p>
</div>
<div class="paragraph">
<p>(Though this is just a demo - in reality, the game would likely live with the small risk and limited impact of this, rather than pay the performance cost for using a transaction.)</p>
</div>
<div class="paragraph">
<p>A complete version of this example is available on our <a href="https://github.com/couchbaselabs/couchbase-transactions-java-examples">GitHub transactions examples page</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L355-L400">public void playerHitsMonster(int damage, String playerId, String monsterId) {
    Transactions transactions = getTransactions();

    try {
        transactions.run((ctx) -&gt; {
            TransactionGetResult monsterDoc = ctx.get(collection, monsterId);
            TransactionGetResult playerDoc = ctx.get(collection, playerId);

            int monsterHitpoints = monsterDoc.contentAs(JsonObject.class).getInt("hitpoints");
            int monsterNewHitpoints = monsterHitpoints - damage;

            if (monsterNewHitpoints &lt;= 0) {
                // Monster is killed.  The remove is just for demoing, and a more realistic example would set a
                // "dead" flag or similar.
                ctx.remove(monsterDoc);

                // The player earns experience for killing the monster
                int experienceForKillingMonster = monsterDoc.contentAs(JsonObject.class).getInt(
                        "experienceWhenKilled");
                int playerExperience = playerDoc.contentAs(JsonObject.class).getInt("experience");
                int playerNewExperience = playerExperience + experienceForKillingMonster;
                int playerNewLevel = calculateLevelForExperience(playerNewExperience);

                JsonObject playerContent = playerDoc.contentAs(JsonObject.class);

                playerContent.put("experience", playerNewExperience);
                playerContent.put("level", playerNewLevel);

                ctx.replace(playerDoc, playerContent);
            } else {
                // Monster is damaged but still alive
                JsonObject monsterContent = monsterDoc.contentAs(JsonObject.class);
                monsterContent.put("hitpoints", monsterNewHitpoints);

                ctx.replace(monsterDoc, monsterContent);
            }
        });
    } catch (TransactionFailed e) {
        // The operation failed.   Both the monster and the player will be untouched.

        // Situations that can cause this would include either the monster
        // or player not existing (as get is used), or a persistent
        // failure to be able to commit the transaction, for example on
        // prolonged node failure.
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="concurrency-with-non-transactional-writes"><a class="anchor" href="#concurrency-with-non-transactional-writes"></a>Concurrency with Non-Transactional Writes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This release of transactions for Couchbase requires a degree of co-operation from the application.
Specifically, the application should ensure that non-transactional writes (such as key-value writes or N1QL UPDATES) are never done concurrently with transactional writes, on the same document.</p>
</div>
<div class="paragraph">
<p>This requirement is to ensure that the strong Key-Value performance of Couchbase was not compromised.
A key philosophy of our transactions is that you 'pay only for what you use'.</p>
</div>
<div class="paragraph">
<p>If two such writes <strong>do</strong> conflict then the transactional write will 'win', overwriting the non-transactional write.</p>
</div>
<div class="paragraph">
<p>Note this only applies to <em>writes</em>.
Any non-transactional <em>reads</em> concurrent with transactions are fine, and are at a Read Committed level.</p>
</div>
<div class="paragraph">
<p>To help detect that this co-operative requirement is fulfilled, the application can subscribe to the client&#8217;s event logger and check for any <code>IllegalDocumentState</code> events, like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L405-L409">cluster.environment().eventBus().subscribe(event -&gt; {
    if (event instanceof IllegalDocumentState) {
        // log this event for review
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>These events will be raised in the event of a non-transactional write being detected and overridden.
The event contains the key of the document involved, to aid the application with debugging.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rollback"><a class="anchor" href="#rollback"></a>Rollback</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If an exception is thrown, either by the application from the lambda, or by the transactions library, then that attempt is rolled back.
The transaction logic may or may not be retried, depending on the exception.</p>
</div>
<div class="paragraph">
<p>If the transaction is not retried then it will throw a <code>TransactionFailed</code> exception, and its <code>getCause</code> method can be used for more details on the failure.</p>
</div>
<div class="paragraph">
<p>The application can use this to signal why it triggered a rollback, as so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L443-L474">class BalanceInsufficient extends RuntimeException {}

try {
    transactions.run((ctx) -&gt; {
        TransactionGetResult customer = ctx.get(collection, "customer-name");

        if (customer.contentAsObject().getInt("balance") &lt; costOfItem) {
            throw new BalanceInsufficient();
        }
        // else continue transaction
    });
} catch (TransactionCommitAmbiguous e) {
    // This exception can only be thrown at the commit point, after the
    // BalanceInsufficient logic has been passed, so there is no need to
    // check getCause here.
    System.err.println("Transaction possibly committed");
    for (LogDefer err : e.result().log().logs()) {
        System.err.println(err.toString());
    }
} catch (TransactionFailed e) {
    if (e.getCause() instanceof BalanceInsufficient) {
        // Re-raise the error
        throw (RuntimeException) e.getCause();
    }
    else {
        System.err.println("Transaction did not reach commit point");

        for (LogDefer err : e.result().log().logs()) {
            System.err.println(err.toString());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The transaction can also be explicitly rolled back:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L428-L435">transactions.run((ctx) -&gt; {
    TransactionGetResult customer = ctx.get(collection, "customer-name");

    if (customer.contentAsObject().getInt("balance") &lt; costOfItem) {
        ctx.rollback();
    }
    // else continue transaction
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, if <code>ctx.rollback()</code> is reached, then the transaction will be regarded as successfully rolled back and no TransactionFailed will be thrown.</p>
</div>
<div class="paragraph">
<p>After a transaction is rolled back, it cannot be committed, no further operations are allowed on it, and the library will not try to automatically commit it at the end of the code block.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="error-handling"><a class="anchor" href="#error-handling"></a>Error Handling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As discussed previously, the transactions library will attempt to resolve many errors itself, through a combination of retrying individual operations and the application&#8217;s lambda.
This includes some transient server errors, and conflicts with other transactions.</p>
</div>
<div class="paragraph">
<p>But there are situations that cannot be resolved, and total failure is indicated to the application via exceptions.
These errors include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Any exception thrown by your transaction lambda, either deliberately or through an application logic bug.</p>
</li>
<li>
<p>Attempting to insert a document that already exists.</p>
</li>
<li>
<p>Attempting to remove or replace a document that does not exist.</p>
</li>
<li>
<p>Calling <code>ctx.get</code> on a document key that does not exist.</p>
</li>
</ul>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Once one of these errors occurs, the current attempt is irrevocably failed (though the transaction may retry the lambda).
It is not possible for the application to catch the failure and continue.
Once a failure has occurred, all other operations tried in this attempt (including commit) will instantly fail.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Transactions, as they are multi-stage and multi-document, also have a concept of partial success/failure.
This is signalled to the application through the <code>TransactionResult.unstagingComplete()</code> method, described later.</p>
</div>
<div class="paragraph">
<p>There are three exceptions that the transactions library can raise to the application: <code>TransactionFailed</code>, <code>TransactionExpired</code> and <code>TransactionCommitAmbiguous</code>.
All exceptions derive from <code>TransactionFailed</code> for backwards-compatibility purposes.</p>
</div>
<div class="sect2">
<h3 id="transactionfailed-and-transactionexpired"><a class="anchor" href="#transactionfailed-and-transactionexpired"></a>TransactionFailed and TransactionExpired</h3>
<div class="paragraph">
<p>The transaction definitely did not reach the commit point.
<code>TransactionFailed</code> indicates a fast-failure whereas <code>TransactionExpired</code> indicates that retries were made until the expiration point was reached, but this distinction is not normally important to the application and generally <code>TransactionExpired</code> does not need to be handled individually.</p>
</div>
<div class="paragraph">
<p>Either way, an attempt will have been made to rollback all changes.
This attempt may or may not have been successful, but the results of this will have no impact on the protocol or other actors.
No changes from the transaction will be visible (presently with the potential and temporary exception of staged inserts being visible to non-transactional actors, as discussed under <a href="#inserting">Inserting</a>).</p>
</div>
<div class="paragraph">
<p><strong>Handling:</strong> Generally, debugging exactly why a given transaction failed requires review of the logs, so it is suggested that the application log these on failure.
(see <a href="#logging">Logging</a>).
The application may want to try the transaction again later.
Alternatively, if transaction completion time is not a priority, then transaction expiration times (which default to 15 seconds) can be extended across the board through <code>TransactionConfigBuilder</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L547-L549">Transactions transactions = Transactions.create(cluster, TransactionConfigBuilder.create()
        .expirationTime(Duration.ofSeconds(120))
        .build());</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will allow the protocol more time to get past any transient failures (for example, those caused by a cluster rebalance).
The tradeoff to consider with longer expiration times, is that documents that have been staged by a transaction are effectively locked from modification from other transactions, until the expiration time has exceeded.</p>
</div>
<div class="paragraph">
<p>Note that expiration is not guaranteed to be followed precisely.
For example, if the application were to do a long blocking operation inside the lambda (which should be avoided), then expiration can only trigger after this finishes.
Similarly, if the transaction attempts a key-value operation close to the expiration time, and that key-value operation times out, then the expiration time may be exceeded.</p>
</div>
</div>
<div class="sect2">
<h3 id="transactioncommitambiguous"><a class="anchor" href="#transactioncommitambiguous"></a>TransactionCommitAmbiguous</h3>
<div class="paragraph">
<p>As discussed <a href="#mechanics">previously</a>, each transaction has a 'single point of truth' that is updated atomically to reflect whether it is committed.</p>
</div>
<div class="paragraph">
<p>However, it is not always possible for the protocol to become 100% certain that the operation was successful, before the transaction expires.
That is, the operation may have successfully completed on the cluster, or may succeed soon, but the protocol is unable to determine this (whether due to transient network failure or other reason).
This is important as the transaction may or may not have reached the commit point, e.g. succeeded or failed.</p>
</div>
<div class="paragraph">
<p>The library raises TransactionCommitAmbiguous to indicate this state.
It should be rare to receive this exception.</p>
</div>
<div class="paragraph">
<p>If the transaction had in fact successfully reached the commit point, then the transaction will be fully completed ("unstaged") by the asynchronous cleanup process at some point in the future.
With default settings this will usually be within a minute, but whatever underlying fault has caused the TransactionCommitAmbiguous may lead to it taking longer.</p>
</div>
<div class="paragraph">
<p>If the transaction had not in fact reached the commit point, then the asynchronous cleanup process will instead attempt to roll it back at some point in the future.
If unable to, any staged metadata from the transaction will not be visible, and will not cause problems (e.g. there are safety mechanisms to ensure it will not block writes to these documents for long).</p>
</div>
<div class="paragraph">
<p><strong>Handling:</strong> This error can be challenging for an application to handle.
As with <code>TransactionFailed</code> it is recommended that it at least writes any logs from the transaction, for future debugging.
It may wish to retry the transaction at a later point, or globally extend transactional expiration times to give the protocol additional time to resolve the ambiguity.</p>
</div>
</div>
<div class="sect2">
<h3 id="transactionresult-unstagingcomplete"><a class="anchor" href="#transactionresult-unstagingcomplete"></a>TransactionResult.unstagingComplete()</h3>
<div class="paragraph">
<p>As above, there is a 'single point of truth' for a transaction.
After this atomic commit point is reached, the documents themselves will still be individually committed (we also call this "unstaging").
However, transactionally-aware actors will now be returning the post-transaction versions of the documents, and the transaction is effectively fully committed to those actors.</p>
</div>
<div class="paragraph">
<p>So if the application is solely working with transaction-aware actors, then the unstaging process is optional.
And failures during the unstaging process are not particularly important, in this case.
(Note the asynchronous cleanup process will still complete the unstaging process at a later point.)</p>
</div>
<div class="paragraph">
<p>Hence, many errors during unstaging will cause the transaction to immediately return success.
That is, successful return simply means that the commit point was reached.</p>
</div>
<div class="paragraph">
<p>A method <code>TransactionResult.unstagingComplete()</code> indicates whether the unstaging process completed successfully or not.
This should be used any time that the application needs all results of the transaction to be immediately available to non-transactional actors (which currently includes N1QL and non-transactional Key-Value reads).</p>
</div>
<div class="paragraph">
<p>Error handling differs depending on whether a transaction is before or after the point of commit (or rollback).</p>
</div>
</div>
<div class="sect2">
<h3 id="full-error-handling-example"><a class="anchor" href="#full-error-handling-example"></a>Full Error Handling Example</h3>
<div class="paragraph">
<p>Pulling all of the above together, this is the suggested best practice for error handling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L617-L656">try {
    TransactionResult result = transactions.run((ctx) -&gt; {
        // ... transactional code here ...
    });

    // The transaction definitely reached the commit point. Unstaging
    // the individual documents may or may not have completed

    if (result.unstagingComplete()) {
        // Operations with non-transactional actors will want
        // unstagingComplete() to be true.
        cluster.query(" ... N1QL ... ",
                QueryOptions.queryOptions()
                        .consistentWith(result.mutationState()));

        String documentKey = "a document key involved in the transaction";
        GetResult getResult = collection.get(documentKey);
    }
    else {
        // This step is completely application-dependent.  It may
        // need to throw its own exception, if it is crucial that
        // result.unstagingComplete() is true at this point.
        // (Recall that the asynchronous cleanup process will
        // complete the unstaging later on).
    }
}
catch (TransactionCommitAmbiguous err) {
    // The transaction may or may not have reached commit point
    System.err.println("Transaction returned TransactionCommitAmbiguous and" +
            " may have succeeded, logs:");

    // Of course, the application will want to use its own logging rather
    // than System.err
    err.result().log().logs().forEach(log -&gt; System.err.println(log.toString()));
}
catch (TransactionFailed err) {
    // The transaction definitely did not reach commit point
    System.err.println("Transaction failed with TransactionFailed, logs:");
    err.result().log().logs().forEach(log -&gt; System.err.println(log.toString()));
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="asynchronous-cleanup"><a class="anchor" href="#asynchronous-cleanup"></a>Asynchronous Cleanup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Transactions will try to clean up after themselves in the advent of failures.
However, there are situations that inevitably created failed, or 'lost' transactions, such as an application crash.</p>
</div>
<div class="paragraph">
<p>This requires an asynchronous cleanup task, described in this section.</p>
</div>
<div class="paragraph">
<p>Creating the <code>Transactions</code> object spawns a background cleanup task, whose job it is to periodically scan for expired transactions and clean them up.
It does this by scanning a subset of the Active Transaction Record (ATR) transaction metadata documents on a bucket.
As you&#8217;ll recall from <a href="#mechanics">earlier</a>, an entry for each transaction attempt exists in one of these documents.
(They are removed during cleanup or at some time after successful completion.)</p>
</div>
<div class="paragraph">
<p>The default settings are tuned to find expired transactions reasonably quickly, while creating neglible impact from the background reads required by the scanning process.
To be exact, with default settings it will generally find expired transactions within 60 seconds, and use less than 20 reads per second.
This is unlikely to impact performance on any cluster, but the settings may be <a href="#tuning-cleanup">tuned</a> as desired.</p>
</div>
<div class="paragraph">
<p>Cleanup is done on each bucket in the cluster.</p>
</div>
<div class="paragraph">
<p>All applications connected to the same cluster and running <code>Transactions</code> will share in the cleanup, via a low-touch communication protocol on the "_txn:client-record" metadata document that will be created in each bucket in the cluster.
This document is visible and should not be modified externally.
It is maintained automatically by the transactions library.
All ATRs on a bucket will be distributed between all cleanup clients, so increasing the number of applications will not increase the reads required for scanning.</p>
</div>
<div class="paragraph">
<p>An application may cleanup transactions created by another application.</p>
</div>
<div class="paragraph">
<p>It is important to understand that if an application is not running, then cleanup is not running.
(This is particularly relevant to developers running unit tests or similar.)</p>
</div>
<div class="paragraph">
<p>If this is an issue, then the deployment may want to consider running a simple application at all times that just    opens a <code>Transactions</code> object, to guarantee that cleanup is running.</p>
</div>
<div class="sect2">
<h3 id="tuning-cleanup"><a class="anchor" href="#tuning-cleanup"></a>Configuring Cleanup</h3>
<div class="paragraph">
<p>The cleanup settings can be configured as so:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Setting</th>
<th class="tableblock halign-left valign-top">Default</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cleanupWindow</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60 seconds</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This determines how long a cleanup 'run' is; that is, how frequently this client will check its subset of ATR documents.  It is perfectly valid for the application to change this setting, which is at a conservative default.  Decreasing this will cause expiration transactions to be found more swiftly (generally, within this cleanup window), with the tradeoff of increasing the number of reads per second used for the scanning process.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cleanupLostAttempts</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This is the thread that takes part in the distributed cleanup process described above, that cleans up expired transactions created by any client.  It is strongly recommended that it is left enabled.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cleanupClientAttempts</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">This thread is for cleaning up transactions created just by this client.  The client will preferentially aim to send any transactions it creates to this thread, leaving transactions for the distributed cleanup process only when it is forced to (for example, on an application crash).  It is strongly recommended that it is left enabled.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="monitoring-cleanup"><a class="anchor" href="#monitoring-cleanup"></a>Monitoring Cleanup</h3>
<div class="paragraph">
<p>If the application wishes to monitor cleanup it may subscribe to these events:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L415-L420">cluster.environment().eventBus().subscribe(event -&gt; {
    if (event instanceof TransactionCleanupAttempt
            || event instanceof TransactionCleanupEndRunEvent) {
        // log this event
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>TransactionCleanupEndRunEvent</code> is raised whenever a current 'run' is finished, and contains statistics from the run.
(A run is typically around every 60 seconds, with default configuration.)</p>
</div>
<div class="paragraph">
<p>A <code>TransactionCleanupAttempt</code> event is raised when an expired transaction was found by this process, and a cleanup attempt was made.
It contains whether that attempt was successful, along with any logs relevant to the attempt.</p>
</div>
<div class="paragraph">
<p>In addition, if cleanup fails to cleanup a transaction that is more than two hours past expiry, it will raise the <code>TransactionCleanupAttempt</code> event at WARN level (rather than the default DEBUG).
With most default configurations of the event-bus (see <a href="#logging">Logging</a> below), this will cause that event to be logged somewhere visible to the application.
If there is not a good reason for the cleanup to be failed (such as a downed node that has not yet been failed-over), then the user is encouraged to report the issue.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="logging"><a class="anchor" href="#logging"></a>Logging</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To aid troubleshooting, each transaction maintains a list of log entries, which can be logged on failure like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L102-L116">} catch (TransactionCommitAmbiguous e) {
    // The application will of course want to use its own logging rather
    // than System.err
    System.err.println("Transaction possibly committed");

    for (LogDefer err : e.result().log().logs()) {
        System.err.println(err.toString());
    }
} catch (TransactionFailed e) {
    System.err.println("Transaction did not reach commit point");

    for (LogDefer err : e.result().log().logs()) {
        System.err.println(err.toString());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>or for the asynchronous API:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L136-L148">}).doOnError(err -&gt; {
    if (err instanceof TransactionCommitAmbiguous) {
        System.err.println("Transaction possibly committed: ");
    }
    else {
        System.err.println("Transaction failed: ");
    }

    for (LogDefer e : ((TransactionFailed) err).result().log().logs()) {
        // System.err is used for example, log failures to your own logging system
        System.err.println(err.toString());
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>A failed transaction can involve dozens, even hundreds, of lines of logging, so the application may prefer to write failed transactions into a separate file.</p>
</div>
<div class="paragraph">
<p>For convenience there is also a config option that will automatically write this programmatic log to the standard Couchbase Java logging configuration inherited from the SDK if a transaction fails.
This will log all lines of any failed transactions, to <code>WARN</code> level:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L81">.logOnFailure(true, Event.Severity.WARN)</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default the Couchbase Java logging event-bus is setup to look for and use SLF4J/logback, log4j1, and log4j2 on the classpath, and to fallback to java.util.Logging.</p>
</div>
<div class="paragraph">
<p>Please see the <a href="collecting-information-and-logging.html" class="xref page">Java SDK logging documentation</a> for details.</p>
</div>
<div class="paragraph">
<p>Most applications will have their own preferred Java logging solution in-place already.
For those starting from scratch here is a complete example using the basic <code>java.util.Logging</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L662-L679">final Logger LOGGER = Logger.getLogger("transactions");

try {
    TransactionResult result = transactions.run((ctx) -&gt; {
        // ... transactional code here ...
    });
}
catch (TransactionCommitAmbiguous err) {
    // The transaction may or may not have reached commit point
    LOGGER.info("Transaction returned TransactionCommitAmbiguous and" +
            " may have succeeded, logs:");
    err.result().log().logs().forEach(log -&gt; LOGGER.info(log.toString()));
}
catch (TransactionFailed err) {
    // The transaction definitely did not reach commit point
    LOGGER.info("Transaction failed with TransactionFailed, logs:");
    err.result().log().logs().forEach(log -&gt; LOGGER.info(log.toString()));
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="concurrent-operations-with-the-async-api"><a class="anchor" href="#concurrent-operations-with-the-async-api"></a>Concurrent Operations with the Async API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The async API allows operations to be performed concurrently inside a transaction, which can assist performance.
There are two rules the application needs to follow:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The first mutation must be performed alone, in serial.
This is because the first mutation also triggers the creation of metadata for the transaction.</p>
</li>
<li>
<p>All concurrent operations must be allowed to complete fully, so the transaction library can track which operations need to be rolled back in the event of failure.
This means the application must 'swallow' the error, but record that an error occurred, and then at the end of the concurrent operations, if an error occurred, throw an error to cause the transaction to retry.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These rules are demonstrated here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L565-L611">List&lt;String&gt; docIds = Arrays.asList("doc1", "doc2", "doc3", "doc4", "doc5");

ReactiveCollection coll = collection.reactive();

TransactionResult result = transactions.reactive((ctx) -&gt; {

    // Tracks whether all operations were successful
    AtomicBoolean allOpsSucceeded = new AtomicBoolean(true);

    // The first mutation must be done in serial, as it also creates a metadata entry
    return ctx.get(coll, docIds.get(0))
            .flatMap(doc -&gt; {
                JsonObject content = doc.contentAsObject();
                content.put("value", "updated");
                return ctx.replace(doc, content);
            })

            // Do all other docs in parallel
            .thenMany(Flux.fromIterable(docIds.subList(1, docIds.size()))
                    .flatMap(docId -&gt; ctx.get(coll, docId)
                                    .flatMap(doc -&gt; {
                                        JsonObject content = doc.contentAsObject();
                                        content.put("value", "updated");
                                        return ctx.replace(doc, content);
                                    })
                                    .onErrorResume(err -&gt; {
                                        allOpsSucceeded.set(false);
                                        // App should replace this with logging
                                        err.printStackTrace();

                                        // Allow other ops to finish
                                        return Mono.empty();
                                    }),

                            // Run these in parallel
                            docIds.size())

            // The commit or rollback must also be done in serial
            ).then(Mono.defer(() -&gt; {
                // Commit iff all ops succeeded
                if (allOpsSucceeded.get()) {
                    return ctx.commit();
                } else {
                    throw new RuntimeException("Retry the transaction");
                }
            }));
}).block();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="custom-metadata-collections"><a class="anchor" href="#custom-metadata-collections"></a>Custom Metadata Collections</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As described above, transactions create and use metadata documents, that are created in the bucket of the first mutated document in the transaction.</p>
</div>
<div class="paragraph">
<p>With Couchbase Server 7.0 beta comes support for scopes and collections, providing a more granular way of organising documents.</p>
</div>
<div class="paragraph">
<p>You can now, completely optionally, use a collection to store the metadata documents, using a new configuration parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L724-L726">Transactions transactions = Transactions.create(cluster,
        TransactionConfigBuilder.create()
                .metadataCollection(metadataCollection));</code></pre>
</div>
</div>
<div class="paragraph">
<p>When specified:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Any transactions created from this <code>Transactions</code> object, will create and use metadata in that collection.</p>
</li>
<li>
<p>The asynchronous cleanup started by this <code>Transactions</code> object will be looking for expired transactions only in this collection.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Most users will not need to use custom metadata collections, and can continue to use the existing 'out-of-the-box' behaviour.
They are provided for these use-cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The metadata documents contain, for documents involved in each transaction, the document&#8217;s key and the name of the bucket, scope and collection it exists on.
Some deployments may not want to potentially 'leak' this data across buckets, scopes and collections.
In which case a metadata collection can be created, with appropriate RBAC permissions to control visibility.</p>
</li>
<li>
<p>If the user wants to remove the default collection entirely.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Support for custom metadata collections in 1.1.3 is at beta level and is marked as @Stability.Volatile, which means the API may need to change as we gather feedback during the Couchbase Server 7.0 beta period.
The feature should not be used in any production deployment while it is at beta level.
Please take this opportunity to provide feedback on this feature, via either support or our forums.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="deferred-commits"><a class="anchor" href="#deferred-commits"></a>Deferred Commits</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The deferred commit feature is currently in alpha, and the API may change.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Deferred commits allow a transaction to be paused just before the commit point.
Optionally, everything required to finish the transaction can then be bundled up into a context that may be serialized into a String or byte array, and deserialized elsewhere (for example, in another process).
The transaction can then be committed, or rolled back.</p>
</div>
<div class="paragraph">
<p>The intention behind this feature is to allow multiple transactions, potentially spanning multiple databases, to be brought to just before the commit point, and then all committed together.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example of deferring the initial commit and serializing the transaction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L481-L505">try {
    TransactionResult result = transactions.run((ctx) -&gt; {
        JsonObject initial = JsonObject.create().put("val", 1);
        ctx.insert(collection, "a-doc-id", initial);

        // Defer means don't do a commit right now.  `serialized` in the result will be present.
        ctx.defer();
    });

    // Available because ctx.defer() was called
    assert (result.serialized().isPresent());

    TransactionSerializedContext serialized = result.serialized().get();

    // This is going to store a serialized form of the transaction to pass around
    byte[] encoded = serialized.encodeAsBytes();

} catch (TransactionFailed e) {
    // System.err is used for example, log failures to your own logging system
    System.err.println("Transaction did not reach commit point");

    for (LogDefer err : e.result().log().logs()) {
        System.err.println(err.toString());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And then committing the transaction later:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L511-L523">TransactionSerializedContext serialized = TransactionSerializedContext.createFrom(encoded);

try {
    TransactionResult result = transactions.commit(serialized);

} catch (TransactionFailed e) {
    // System.err is used for example, log failures to your own logging system
    System.err.println("Transaction did not reach commit point");

    for (LogDefer err : e.result().log().logs()) {
        System.err.println(err.toString());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively the transaction can be rolled back:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java" data-source-url="https://github.com/couchbase/docs-sdk-java/blob/9ecdb1cbd382ef046be0f92b825773a97a52d93a/modules/howtos/examples/TransactionsExample.java#L529-L541">TransactionSerializedContext serialized = TransactionSerializedContext.createFrom(encoded);

try {
    TransactionResult result = transactions.rollback(serialized);

} catch (TransactionFailed e) {
    // System.err is used for example, log failures to your own logging system
    System.err.println("Transaction did not reach commit point");

    for (LogDefer err : e.result().log().logs()) {
        System.err.println(err.toString());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The transaction expiry timer (which is configurable) will begin ticking once the transaction starts, and is not paused while the transaction is in a deferred state.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="further-reading"><a class="anchor" href="#further-reading"></a>Further Reading</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Thereâ€™s plenty of explanation about how Transactions work in Couchbase in our <a href="#6.6@server:learn:data/transactions.adoc" class="xref unresolved">Transactions documentation</a>.</p>
</li>
<li>
<p>You can find further code examples on our <a href="https://github.com/couchbaselabs/couchbase-transactions-java-examples">transactions examples repository</a>.</p>
</li>
</ul>
</div>
</div>
</div>
</article>
</main>
</div>
<footer class="footer">
  <div class="container">
    <div class="footer-links">
      <div class="col">
        <div class="footer-logo">
          <a href="https://www.couchbase.com" class="icon">
            <img src="../../../_/img/couchbase-logo.svg" alt="Couchbase">
          </a>
        </div>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://docs.couchbase.com" target="_blank" rel="noopener">Documentation</a></li>
          <li><a href="https://forums.couchbase.com" target="_blank" rel="noopener">Forums</a></li>
          <li><a href="https://support.couchbase.com" target="_blank" rel="noopener">Support</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://developer.couchbase.com" target="_blank" rel="noopener">Developer Portal</a></li>
          <li><a href="https://blog.couchbase.com" target="_blank" rel="noopener">Blog</a></li>
          <li><a href="https://www.couchbase.com/resources">Resources</a></li>
        </ul>
      </div>
      <div class="col">
        <ul>
          <li><a href="https://www.couchbase.com/get-started-developing-nosql">Get Started</a></li>
          <li><a href="https://www.couchbase.com/downloads">Downloads</a></li>
          <li><a href="https://learn.couchbase.com/store?utf8=%E2%9C%93&ss=1&ct=78327&commit=Filter" target="_blank" rel="noopener">Training</a></li>
        </ul>
      </div>
      <div class="col">
        <ul class="social-icons">
          <li>
            <svg  width="14" height="14" viewBox="0 0 32.1 26.1"> <path id="twitter" class="cls-1" d="M32,7.1a11.836,11.836,0,0,1-3.8,1,6.462,6.462,0,0,0,2.9-3.6,12.606,12.606,0,0,1-4.2,1.6A6.492,6.492,0,0,0,22.1,4a6.594,6.594,0,0,0-6.6,6.6,7.719,7.719,0,0,0,.2,1.5A18.458,18.458,0,0,1,2.2,5.2a6.294,6.294,0,0,0-.9,3.3A6.765,6.765,0,0,0,4.2,14a6.109,6.109,0,0,1-3-.8v.1a6.543,6.543,0,0,0,5.3,6.4,4.678,4.678,0,0,1-1.7.2,4.869,4.869,0,0,1-1.2-.1,6.679,6.679,0,0,0,6.1,4.6,12.917,12.917,0,0,1-8.2,2.8,9.151,9.151,0,0,1-1.6-.1,18.438,18.438,0,0,0,10.1,3c12.1,0,18.7-10,18.7-18.7v-.8A13.336,13.336,0,0,0,32,7.2Z" transform="translate(0.1 -4)"/></svg>
            <a href="https://twitter.com/couchbase" class="icon">
              Twitter
            </a>
          </li>
          <li>
          <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="linkedin" class="cls-1" d="M29,0H3A3.076,3.076,0,0,0,0,3V29a3.009,3.009,0,0,0,3,3H29a2.946,2.946,0,0,0,3-3V3A3.009,3.009,0,0,0,29,0ZM12,26H8V12h4ZM10,10a2,2,0,1,1,2-2A2.006,2.006,0,0,1,10,10ZM26,26H22V18a2,2,0,0,0-4,0v8H14V12h4v2.5c.8-1.1,2.1-2.5,3.5-2.5A4.736,4.736,0,0,1,26,17Z"/></svg>
              <a href="https://www.linkedin.com/company/couchbase" class="icon">
             Linkedin
            </a>
          </li>
          <li>
            <svg  width="14" height="14" viewBox="0 0 32 32"> <path id="facebook" class="cls-1" d="M29,0H3A2.652,2.652,0,0,0,0,3V29a2.652,2.652,0,0,0,3,3H16V18H12V14h4V12a6.452,6.452,0,0,1,6-6h4v4H22a2.151,2.151,0,0,0-2,2v2h6l-1,4H20V32h9a2.652,2.652,0,0,0,3-3V3A2.652,2.652,0,0,0,29,0Z"/></svg>
            <a href="https://www.facebook.com/Couchbase" class="icon">
            Facebook
            </a>
          </li>
        </ul>
      </div>
    </div>
    <div class="footer-terms">
      <div class="footer-terms-copyright">
          <span>Â© 2024 Couchbase, Inc. Couchbase, Couchbase Lite and the Couchbase logo are registered trademarks of Couchbase, Inc.</span>
      </div>
      <div class="footer-terms-links">
        <a href="https://www.couchbase.com/terms-of-use">Terms of Use</a>
        <a href="https://www.couchbase.com/privacy-policy">Privacy Policy</a>
        <a href="https://www.couchbase.com/cookie-policy">Cookie Policy</a>
        <a href="https://www.couchbase.com/support-policy">Support Policy</a>
        <a href="https://info.couchbase.com/unsubscribe-or-manage-preferences.html" target="_blank" rel="noopener">Marketing Preference Center</a>
      </div>
    </div>
  </div>
</footer>
<script src="../../../_/js/site-navigation-data.js"></script>
<script id="page-navigation-group" type="application/json">
{"title":"SDKs","components":["dotnet-sdk","c-sdk","go-sdk","java-sdk","kotlin-sdk","nodejs-sdk","php-sdk","python-sdk","ruby-sdk","scala-sdk","cxx-txns","elasticsearch-connector","kafka-connector","spark-connector","tableau-connector","sdk-extensions"],"latestVersions":{"dotnet-sdk":"3.4","c-sdk":"3.3","go-sdk":"2.6","java-sdk":"3.4","kotlin-sdk":"1.1","nodejs-sdk":"4.2","php-sdk":"4.0","python-sdk":"4.1","ruby-sdk":"3.3","scala-sdk":"1.4","cxx-txns":"1.0","elasticsearch-connector":"4.4","kafka-connector":"4.1","spark-connector":"3.3","tableau-connector":"1.x","sdk-extensions":"master"}}
</script>
<template id="run-code-panel">
<div class="action-panel">
  <form class="action-panel-control" method="POST" action="https://couchbase.live/run" target="run-code-output">
    <input type="hidden" name="lang">
    <input type="hidden" name="code">
    <input type="hidden" name="from" value="docs">
    <div class="controls">
      <button class="control-button rerun" type="submit"><i class="fas fa-redo"></i></button>
      <span class="shell-name control-label">Output</span>
      <button class="control-button close"><i class="fas fa-times"></i> Close</button>
    </div>
  </form>
  <iframe class="run-code-output" name="run-code-output"></iframe>
</div>
</template>
<script id="site-script" src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/tabs.js" data-sync-storage-key="preferred-tab"></script>
<script defer src="../../../_/js/vendor/fontawesome-icon-defs.js"></script>
<script defer src="../../../_/js/vendor/fontawesome.js" data-search-pseudo-elements="true"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
</body>
</html>
